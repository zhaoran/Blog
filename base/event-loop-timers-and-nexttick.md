## 什么是事件循环？

事件循环使得nodejs可以执行非阻塞的IO操作，尽管js是单线程的，将操作转移到系统内核来执行

因为绝大部分的现代内核是多线程的，他们能够在后台同时处理多项操作。当某个操作完成时，内核通知nodejs，从而将回调方法添加到队列中以便最终执行。关于这一点，我们会进一步讨论

## 解释事件循环

当nodejs启动时，会初始化事件循环，处理输入的脚本，这些脚本可能会发出异步api请求，计划定时器，或者调用 process.nextTick()，然后开始处理事件循环。

下面的图表展示了一个简化的事件循环操作流程。

注意：每一个块代表着事件循环的一个阶段

每一个阶段都要执行一个FIFO的回调队列。每一个阶段都是特别的，当事件循环进入了指定的阶段，就会执行该阶段特有的操作，然后执行改阶段队列中的毁回调方法，直到队列处理完毕或者达到了最大处理数量。当队列处理完毕或者达到最大处理数量时，事件循环就会转移到下个阶段，以此类推。

因为任意的这些操作都可能规划更多的操作，在poll中处理的新的事件被内核插入，当polling事件被执行的时候，poll事件也可以被插入。结果是，长时间执行的回调方法允许poll阶段运行时间超过timer的阈值。更多细节请参考 timers 和 poll 章节。

注意：Windows 和 Unix/Linux 的实现有细微的差异，但是不影响这次的展示。这里是最重要的部分。实际上有7或者8个步骤，但是nodejs实际上使用的，也就是我们本次关注的，只是上面的这些。

## 阶段概述

- timers: 这个阶段执行 setTimeout() 和 setInterval() 方法的回调
- I/O callbacks 执行除了关闭回调、timers回调、setImmediate() 回调之外的几乎所有回调
- idle, prepare 仅供内部使用
- poll 提取新的 I/O 事件；有时候node可能会在这里阻塞
- check setImmediate() 回调会在这里触发
- close callbacks 比如 socket.on('close', ...)

每一次事件循环中，nodejs 检查是否在等待异步的I/O或者timers回调，如果没有的话，就关闭。

## 阶段详情

### timers

定时器指定某个时间间隔之后回调函数可能会执行，而不是一个精确的时间。Timers 回调在指定的时间间隔过去之后会尽快执行；然而，操作系统的计划任务或者其他回调方法可能使其延迟。

注意：技术上来说，poll 阶段控制了timers什么时候执行

例如，你设置了一个100ms后执行的回调，然后你的脚本开始异步执行一个耗时95ms的读取文件操作：

当事件循环进入poll阶段，只有一个空的队列，因此，他会等待直到达到最近的定时器阈值。当95ms过去后，fs.readFile() 完成了读取文件操作，他的耗时10ms的回调方法被加入了poll队列并执行。当这个回调方法执行完毕后，这个队列中再也没有其他回调方法了，因此事件循环会发现定时器时间到了，就会回到timers阶段来执行定时器回调。在本例中，定时器被计划到真正被执行之间的时间间隔是105ms。

注意：为了防止poll阶段饿死事件循环，libuv （nodejs中事件循环和所有平台异步操作所使用的c语言库）有一个硬编码的最大回调数量（依赖于操作系统），超过阈值后会强制中断poll阶段执行。

### I/O callbacks

这个阶段执行TCP错误之类的系统操作。例如，如果一个TCP 套接字试图发起连接的时候接收到了 ECONNREFUSED 消息，一些 *nix 系统会等待报告这个错误。其就会在 I/O回调阶段被执行。

### poll

poll 阶段有两个主要功能：
1. 当阈值达到时执行定时器脚本
2. 处理 poll 队列中的事件

当事件循环进入到了poll阶段并且没有定时器时，会发生下面两种情况之一：

- 如果poll队列不为空，事件循环会迭代同步执行队列中的回调方法，直到队列为空或者达到了最大回调数量限制。
- 如果poll队列为空，还会执行下面两种操作：
    - 如果有 setImmediate() 方法执行了，事件循环会结束poll阶段，进入到check阶段来执行脚本
    - 如果没有 setImmediate() 方法，事件循环会等待回调方法加入队列，然后立即执行。

一旦poll队列为空的话，事件循环会检查是否有定时器达到时间。如果有一个或多个定时器达到时间了，事件循环会进入到timers阶段执行这些定时器回调。

### check

这个阶段可以让我们在poll阶段结束之后立即执行回调方法。如果poll阶段空闲了，并且有脚本被 setImmediate() 方法推入队列，事件循环就会进入到check阶段而不是继续等待。

setImmediate() 实际上是一个运行在事件循环的独立阶段的特殊定时器。他使用一个libuv的API来规划在poll阶段完成之后执行回调方法。

一般来说，随着代码的执行，事件循环最终会到达poll阶段，在这里等待进入的连接、请求等等。然而，如果有 setImmediate() 方法规划的回调方法的话，poll阶段空闲时就会结束，进入到check阶段，而不是继续等待poll事件。

### close callbacks

如果一个套接字或者句柄被突然关闭了（例如 socket.destroy()），close 事件会在这个阶段被触发。否则这个事件会通过 process.nextTick() 来触发。

## setImmediate() VS setTimeout() 

setImmediate() 和 setTimeout() 是相似的，但是调用时机的不同会导致他们有一些不同的行为。

- setImmediate() 是当poll阶段完成时立即执行脚本的
- setTimeout() 规划经过一个最小时间间隔之后执行脚本

他们执行的顺序依赖于调用的上下文环境。如果他们都是在主流程中调用，时间线就依赖于进程的性能（可能会被运行在机器上的其他应用影响）。

例如，如果我们运行下面的不在I/O循环中的脚本（也就是说在主流程中），这两个定时器的执行顺序是不确定的，依赖于进程的性能：

然而，如果你在I/O循环内调用他们的话，immediate 回调总是会先执行。

使用 setImmediate() 的主要优势是在I/O循环中，他总是会在其他任何定时器之前执行。

## process.nextTick()

### 理解 process.nextTick()

你或许注意到了 process.nextTick() 没有显示在这个图表中，尽管他也是异步API的一部分。这是因为，从技术上讲，process.nextTick() 不属于事件循环的一部分。nextTickQueue 会在当前操作完成后执行，而不论是在事件循环中的哪个阶段。

回头看上面的图表，任何时候你调用 process.nextTick() ，其回调方法都会在事件循环继续进行之前被调用。这会导致一些不好的场景，因为他可以通过递归调用 process.nextTick()来“饿死”I/O进程，阻止事件循环进入poll阶段。

### 为什么可以这样

为什么nodejs会包含这种机制呢？部分的设计哲学是尽管不是必须的，但一个API应该总是异步的。以下面的代码片段为例：

这段代码检查参数，如果参数有误，就将错误传递给回调方法。最近 process.nextTick() 接口做了更新，允许向其传递参数，从而可以进一步传递给回调方法，这样就不必做函数嵌套了。

我们做的是给用户传递一个错误，但是这要在其他用户代码执行完毕之后。通过使用 process.nextTick() 我们确保了 apiCall() 会在其他用户代码执行之后，在事件循环之前执行回调。为了做到这一点，JS 调用栈在空闲后，立即执行回调方法，允许用户执行递归回调方法而不会导致错误 RangeError: Maximum call stack size exceeded from v8。

这种设计思想会导致一些潜藏的有问题的情况。例如下面这段代码：

用户定义了 someAsyncApiCall() 方法看起来是个异步方法，但实际上却是一个同步方法。他执行的时候， someAsyncApiCall() 方法提供的回调方法会在事件循环的同一个阶段被调用因为该方法实际上并没有做任何异步操作。结果是，回调方法试图引用还没有在作用域内的变量 bar，因为脚本还没有执行完毕。

将回调方法置于 process.nextTick() 方法内，脚本就可以运行完毕，将变量、方法等的初始化操作在回调方法之前执行完毕。并且，也会阻止事件循环进入到一下一阶段。当用户想要值事件循环进儒下一阶段之前提示错误的时候比较有用。下面是使用了 process.nextTick() 之后的代码：

下面是另一个实际的例子：

当仅有一个端口号传递到方法时候，立即就会被绑定。所以 listening 回调立即就会被调用。问题是这时候 .on('listening') 还没有执行呢。

将 listening 事件的触发置入 nextTick() 中，脚本就可以执行完毕，用户就可以设置事件方法了。

## process.nextTick() VS setImmediate()

我们有两个相似的方法，他们的名字有一些令人疑惑。

- process.nextTick() 在同一个阶段立即触发
- setImmediate() 在事件循环的下一个循环或 tick 触发

实际上，他们的名字应该对调一下。process.nextTick() 比 setImmediate() 方法更早触发，但是由于历史原因，名字不太可能改变了。调换名字会导致很多npm上的包不可用。每天都有更多的模块加入，意味着我们没多等一天，就会有更多潜在的 breakages 出现。虽然令人困惑，但是名字缺不会改变了。

我们建议开发者使用 setImmediate() 方法因为其更容易理解（并且代码也更容易和其他不同的环境兼容，比如浏览器）。

## 为什么使用 process.nextTick() ？

有两个主要原因：

1. 允许用户处理错误，清理不再需要的资源，或者在事件循环进入下一阶段之前继续发请求。
2. 需要在调用栈执行完毕，事件循环进入下一阶段之前执行回调方法的时候。

一个例子是满足用户的期望。简化后的例子如下：

假如说 listen() 在事件循环的开始阶段执行，但是事件回调放置在 setImmediate() 方法中。现在，除非域名也传递进去，否则端口会立即被绑定。这意味着事件循环要处理回调的话，必须要poll阶段，这也就意味着有一定的机会在listening事件之前就已经收到了一个连接，connection 事件也就被触发了。

另一个例子是，运行一个继承自 EventEmitter 的构造方法，构造方法内部会触发一个事件：

你不能在构造函数内立即触发一个事件，因为脚本还没有处理到添加事件回调的部分。因此，在构造方法内，你可以使用 process.nextTick() 来设置回调方法在构造方法执行完毕之后触发事件，这样可以得到预期的结果：






